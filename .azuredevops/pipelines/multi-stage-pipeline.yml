# # .azuredevops/pipelines/multi-stage-pipeline.yml
# name: $(Build.SourceBranchName)-$(Date:yyyyMMdd)$(Rev:.r)

# trigger:
#   branches:
#     include:
#       - master
#       - release/*
#   paths:
#     exclude:
#       - README.md
#       - '*.md'

# pr:
#   branches:
#     include:
#       - master
#       - release/*
#       - develop
#   paths:
#     exclude:
#       - README.md
#       - '*.md'

# variables:
#   # ACR Details - UPDATE THIS WITH YOUR ACR NAME!
#   - name: acrName
#     value: 'myacrdemo2025'  # CHANGE THIS to your actual ACR name
#   - name: acrLoginServer
#     value: '$(acrName).azurecr.io'
#   - name: imageName
#     value: 'myapp'
#   - name: tag
#     value: '$(Build.SourceBranchName)-$(Build.BuildId)'
  
#   # AKS Namespaces
#   - name: devNamespace
#     value: 'dev-namespace'
#   - name: testNamespace
#     value: 'test-namespace'
#   - name: prodNamespace
#     value: 'prod-namespace'

# stages:
#   # STAGE 1: BUILD
#   - stage: Build
#     displayName: 'Build Docker Image'
#     jobs:
#     - job: BuildJob
#       displayName: 'Build and Push to ACR'
#       pool: 'my-linux-agent'   # ✅ CORRECT: This matches your self-hosted agent pool
      
#       steps:
#       # Step 1: Checkout code
#       - checkout: self
#         fetchDepth: 1
      
#       # Step 2: Setup .NET
#       - task: UseDotNet@2
#         displayName: 'Use .NET 8.0'
#         inputs:
#           version: '8.0.x'
      
#       # Step 3: Restore dependencies
#       - task: DotNetCoreCLI@2
#         displayName: 'Restore dependencies'
#         inputs:
#           command: 'restore'
#           projects: '**/*.csproj'
      
#       # Step 4: Build application
#       - task: DotNetCoreCLI@2
#         displayName: 'Build application'
#         inputs:
#           command: 'build'
#           projects: '**/*.csproj'
#           arguments: '--configuration Release --no-restore'
      
#       # Step 5: Run tests
#       - task: DotNetCoreCLI@2
#         displayName: 'Run tests'
#         inputs:
#           command: 'test'
#           projects: '**/*Tests/*.csproj'
#           arguments: '--configuration Release --no-build --verbosity normal'
      
#       # Step 6: Docker login
#       - task: Docker@2
#         displayName: 'Login to Azure Container Registry'
#         inputs:
#           command: 'login'
#           containerRegistry: 'acr-connection'
      
#       # Step 7: Build and push Docker image
#       - task: Docker@2
#         displayName: 'Build and Push Docker Image'
#         inputs:
#           command: 'buildAndPush'
#           repository: '$(imageName)'
#           dockerfile: 'Dockerfile'
#           buildContext: '$(System.DefaultWorkingDirectory)'
#           containerRegistry: 'acr-connection'
#           tags: |
#             $(tag)
#             latest
      
#       # Step 8: Publish Kubernetes manifests
#       - task: PublishBuildArtifacts@1
#         displayName: 'Publish Kubernetes Manifests'
#         inputs:
#           PathtoPublish: '$(System.DefaultWorkingDirectory)/kubernetes'
#           ArtifactName: 'manifests'

#   # STAGE 2: DEV DEPLOYMENT (Automatic)
#   - stage: Dev
#     displayName: 'Deploy to Dev'
#     dependsOn: Build
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToDev
#       displayName: 'Deploy to Dev AKS'
#       environment: 'dev'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             # Step 1: Download manifests
#             - download: current
#               artifact: manifests
            
#             # Step 2: Create namespace if not exists
#             - task: Bash@3
#               displayName: 'Create dev namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(devNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             # Step 3: Replace image placeholder in deployment
#             - task: Bash@3
#               displayName: 'Update deployment with image tag'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
            
#             # Step 4: Deploy to dev namespace
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Dev'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(devNamespace)

#   # STAGE 3: TEST DEPLOYMENT (Requires approval)
#   - stage: Test
#     displayName: 'Deploy to Test'
#     dependsOn: Dev
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToTest
#       displayName: 'Deploy to Test AKS'
#       environment: 'test'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             - download: current
#               artifact: manifests
            
#             - task: Bash@3
#               displayName: 'Create test namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(testNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Test'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(testNamespace)

#   # STAGE 4: PRODUCTION DEPLOYMENT (Requires approval)
#   - stage: Prod
#     displayName: 'Deploy to Production'
#     dependsOn: Test
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToProd
#       displayName: 'Deploy to Production AKS'
#       environment: 'prod'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             - download: current
#               artifact: manifests
            
#             - task: Bash@3
#               displayName: 'Create prod namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(prodNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Production'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(prodNamespace)
























# .azuredevops/pipelines/multi-stage-pipeline.yml
name: $(Build.SourceBranchName)-$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - master
      - release/*
  paths:
    exclude:
      - README.md
      - '*.md'

pr:
  branches:
    include:
      - master
      - release/*
      - develop
  paths:
    exclude:
      - README.md
      - '*.md'

variables:
  # ACR Details
  - name: acrName
    value: 'myacrdemo2025'
  - name: acrLoginServer
    value: '$(acrName).azurecr.io'
  - name: imageName
    value: 'myapp'
  - name: tag
    value: '$(Build.SourceBranchName)-$(Build.BuildId)'  # e.g., master-61
  
  # AKS Namespaces
  - name: devNamespace
    value: 'dev-namespace'
  - name: testNamespace
    value: 'test-namespace'
  - name: prodNamespace
    value: 'prod-namespace'

stages:
  # STAGE 1: BUILD
  - stage: Build
    displayName: 'Build Docker Image'
    jobs:
    - job: BuildJob
      displayName: 'Build and Push to ACR'
      pool: 'my-linux-agent'
      timeoutInMinutes: 120  #  ADDED: Prevent timeout
      
      steps:
      # Step 1: Checkout code
      - checkout: self
        fetchDepth: 1
      
      # Step 2: Setup .NET
      - task: UseDotNet@2
        displayName: 'Use .NET 8.0'
        inputs:
          version: '8.0.x'
      
      # Step 3: Restore dependencies
      - task: DotNetCoreCLI@2
        displayName: 'Restore dependencies'
        continueOnError: true  #  ADDED: Don't fail pipeline on restore issues
        inputs:
          command: 'restore'
          projects: '**/*.csproj'
      
      # Step 4: Build application
      - task: DotNetCoreCLI@2
        displayName: 'Build application'
        inputs:
          command: 'build'
          projects: '**/*.csproj'
          arguments: '--configuration Release --no-restore'
      
      # Step 5: Run tests
      - task: DotNetCoreCLI@2
        displayName: 'Run tests'
        continueOnError: true  #  ADDED: Continue even if tests fail
        inputs:
          command: 'test'
          projects: '**/*Tests/*.csproj'
          arguments: '--configuration Release --no-build --verbosity normal'
      
      # Step 6: Docker login
      - task: Docker@2
        displayName: 'Login to Azure Container Registry'
        inputs:
          command: 'login'
          containerRegistry: 'acr-connection'
      
      # Step 7: Build and push Docker image
      - task: Docker@2
        displayName: 'Build and Push Docker Image'
        timeoutInMinutes: 30  #  ADDED: Specific timeout for Docker build
        inputs:
          command: 'buildAndPush'
          repository: '$(imageName)'
          dockerfile: 'Dockerfile'
          buildContext: '$(System.DefaultWorkingDirectory)'
          containerRegistry: 'acr-connection'
          tags: |
            $(tag)           #  FIXED: Use specific version tag (master-61)
            #  REMOVED: 'latest' - causes caching issues
      
      # Step 8: Publish Kubernetes manifests
      - task: PublishBuildArtifacts@1
        displayName: 'Publish Kubernetes Manifests'
        inputs:
          PathtoPublish: '$(System.DefaultWorkingDirectory)/kubernetes'
          ArtifactName: 'manifests'
      
      #  ADDED: Verify image was pushed
      - task: Bash@3
        displayName: 'Verify Image in ACR'
        condition: succeeded()
        inputs:
          targetType: 'inline'
          script: |
            echo " Verifying image: $(acrLoginServer)/$(imageName):$(tag)"
            az acr repository show-tags \
              --name $(acrName) \
              --repository $(imageName) \
              --output table
            echo " Image successfully stored in ACR"

  # STAGE 2: DEV DEPLOYMENT (Automatic)
  - stage: Dev
    displayName: 'Deploy to Dev'
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToDev
      displayName: 'Deploy to Dev AKS'
      environment: 'dev'
      pool: 'my-linux-agent'
      timeoutInMinutes: 30  #  ADDED: Prevent timeout
      strategy:
        runOnce:
          deploy:
            steps:
            #  ADDED: Validate kubectl and Minikube
            - task: Bash@3
              displayName: 'Validate Environment'
              inputs:
                targetType: 'inline'
                script: |
                  echo "=== Environment Validation ==="
                  echo "Agent: $(hostname)"
                  kubectl version --client
                  minikube status || echo "Minikube not found"
                  kubectl config current-context
                  kubectl config use-context minikube
                  echo " Environment ready"
            
            # Step 1: Download manifests
            - download: current
              artifact: manifests
            
            #  ADDED: Ensure ACR pull secret exists
            - task: Bash@3
              displayName: 'Ensure ACR Pull Secret'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Creating/updating ACR pull secret..."
                  kubectl config use-context minikube
                  
                  # Get ACR credentials
                  az acr update -n $(acrName) --admin-enabled true
                  USERNAME=$(az acr credential show --name $(acrName) --query "username" -o tsv)
                  PASSWORD=$(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)
                  
                  # Create or update secret
                  kubectl create secret docker-registry acr-secret \
                    --namespace $(devNamespace) \
                    --docker-server=$(acrLoginServer) \
                    --docker-username=$USERNAME \
                    --docker-password=$PASSWORD \
                    --dry-run=client -o yaml | kubectl apply -f -
                  
                  echo " ACR pull secret ready"
            
            # Step 2: Create namespace if not exists
            - task: Bash@3
              displayName: 'Create dev namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  echo "Creating namespace: $(devNamespace)"
                  kubectl create namespace $(devNamespace) --dry-run=client -o yaml | kubectl apply -f -
                  echo " Namespace ready"
            
            # Step 3: Replace image placeholder in deployment
            - task: Bash@3
              displayName: 'Update deployment with image tag'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Updating image to: $(acrLoginServer)/$(imageName):$(tag)"
                  # Backup original
                  cp $(Pipeline.Workspace)/manifests/deployment.yaml $(Pipeline.Workspace)/manifests/deployment.yaml.backup
                  # Replace placeholder
                  sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
                  echo " Deployment updated with versioned tag"
            
            # Step 4: Deploy to dev namespace
            - task: Bash@3
              displayName: 'Deploy to Dev'
              timeoutInMinutes: 10  #  ADDED: Specific timeout
              inputs:
                targetType: 'inline'
                script: |
                  set -e  # Exit on error
                  kubectl config use-context minikube
                  
                  echo "=== Deploying $(acrLoginServer)/$(imageName):$(tag) ==="
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(devNamespace)
                  
                  #  ADDED: Wait for deployment
                  echo "Waiting for rollout..."
                  kubectl rollout status deployment/myapp-deployment -n $(devNamespace) --timeout=120s
                  
                  #  ADDED: Verify deployment
                  echo "=== Verification ==="
                  kubectl get pods -n $(devNamespace) -o wide
                  kubectl get svc -n $(devNamespace) 2>/dev/null || echo "No services found"
                  
                  echo " Deployment successful!"
            
            #  ADDED: Health check
            - task: Bash@3
              displayName: 'Health Check'
              condition: succeeded()
              inputs:
                targetType: 'inline'
                script: |
                  echo "=== Application Health Check ==="
                  kubectl config use-context minikube
                  
                  # Wait for pod to be ready
                  kubectl wait --for=condition=ready pod -l app=myapp -n $(devNamespace) --timeout=60s
                  
                  # Test the application
                  echo "Testing endpoint..."
                  kubectl port-forward deployment/myapp-deployment 8080:8080 -n $(devNamespace) &
                  PID=$!
                  sleep 5
                  
                  if curl -s http://localhost:8080 > /dev/null; then
                    echo " Application is healthy and responding"
                    curl -s http://localhost:8080 | grep -o "<title>[^<]*</title>" || echo " HTML response received"
                  else
                    echo " Application not responding"
                  fi
                  
                  kill $PID 2>/dev/null
                  echo " Dev deployment completed successfully!"

  # STAGE 3: TEST DEPLOYMENT (Requires approval)
  - stage: Test
    displayName: 'Deploy to Test'
    dependsOn: Dev
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToTest
      displayName: 'Deploy to Test AKS'
      environment: 'test'
      pool: 'my-linux-agent'
      timeoutInMinutes: 30
      strategy:
        runOnce:
          deploy:
            steps:
            #  ADDED: Same validation as Dev stage
            - task: Bash@3
              displayName: 'Validate Environment'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
            
            - download: current
              artifact: manifests
            
            #  ADDED: ACR secret for test namespace
            - task: Bash@3
              displayName: 'Ensure ACR Pull Secret (Test)'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  az acr update -n $(acrName) --admin-enabled true
                  USERNAME=$(az acr credential show --name $(acrName) --query "username" -o tsv)
                  PASSWORD=$(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)
                  
                  kubectl create secret docker-registry acr-secret \
                    --namespace $(testNamespace) \
                    --docker-server=$(acrLoginServer) \
                    --docker-username=$USERNAME \
                    --docker-password=$PASSWORD \
                    --dry-run=client -o yaml | kubectl apply -f -
            
            - task: Bash@3
              displayName: 'Create test namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl create namespace $(testNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
            - task: Bash@3
              displayName: 'Deploy to Test'
              inputs:
                targetType: 'inline'
                script: |
                  set -e
                  kubectl config use-context minikube
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(testNamespace)
                  kubectl rollout status deployment/myapp-deployment -n $(testNamespace) --timeout=120s
                  echo " Test deployment successful!"

  # STAGE 4: PRODUCTION DEPLOYMENT (Requires approval)
  - stage: Prod
    displayName: 'Deploy to Production'
    dependsOn: Test
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToProd
      displayName: 'Deploy to Production AKS'
      environment: 'prod'
      pool: 'my-linux-agent'
      timeoutInMinutes: 30
      strategy:
        runOnce:
          deploy:
            steps:
            #  ADDED: Same validation as Dev stage
            - task: Bash@3
              displayName: 'Validate Environment'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
            
            - download: current
              artifact: manifests
            
            #  ADDED: ACR secret for prod namespace
            - task: Bash@3
              displayName: 'Ensure ACR Pull Secret (Prod)'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  az acr update -n $(acrName) --admin-enabled true
                  USERNAME=$(az acr credential show --name $(acrName) --query "username" -o tsv)
                  PASSWORD=$(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv)
                  
                  kubectl create secret docker-registry acr-secret \
                    --namespace $(prodNamespace) \
                    --docker-server=$(acrLoginServer) \
                    --docker-username=$USERNAME \
                    --docker-password=$PASSWORD \
                    --dry-run=client -o yaml | kubectl apply -f -
            
            - task: Bash@3
              displayName: 'Create prod namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl create namespace $(prodNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
            - task: Bash@3
              displayName: 'Deploy to Production'
              inputs:
                targetType: 'inline'
                script: |
                  set -e
                  kubectl config use-context minikube
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(prodNamespace)
                  kubectl rollout status deployment/myapp-deployment -n $(prodNamespace) --timeout=120s
                  echo " Production deployment successful!"