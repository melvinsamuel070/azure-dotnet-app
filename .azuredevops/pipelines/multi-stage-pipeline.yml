# # .azuredevops/pipelines/multi-stage-pipeline.yml
# name: $(Build.SourceBranchName)-$(Date:yyyyMMdd)$(Rev:.r)

# trigger:
#   branches:
#     include:
#       - master
#       - release/*
#   paths:
#     exclude:
#       - README.md
#       - '*.md'

# pr:
#   branches:
#     include:
#       - master
#       - release/*
#       - develop
#   paths:
#     exclude:
#       - README.md
#       - '*.md'

# variables:
#   # ACR Details - UPDATE THIS WITH YOUR ACR NAME!
#   - name: acrName
#     value: 'myacrdemo2025'  # CHANGE THIS to your actual ACR name
#   - name: acrLoginServer
#     value: '$(acrName).azurecr.io'
#   - name: imageName
#     value: 'myapp'
#   - name: tag
#     value: '$(Build.SourceBranchName)-$(Build.BuildId)'
  
#   # AKS Namespaces
#   - name: devNamespace
#     value: 'dev-namespace'
#   - name: testNamespace
#     value: 'test-namespace'
#   - name: prodNamespace
#     value: 'prod-namespace'

# stages:
#   # STAGE 1: BUILD
#   - stage: Build
#     displayName: 'Build Docker Image'
#     jobs:
#     - job: BuildJob
#       displayName: 'Build and Push to ACR'
#       pool: 'my-linux-agent'   # ✅ CORRECT: This matches your self-hosted agent pool
      
#       steps:
#       # Step 1: Checkout code
#       - checkout: self
#         fetchDepth: 1
      
#       # Step 2: Setup .NET
#       - task: UseDotNet@2
#         displayName: 'Use .NET 8.0'
#         inputs:
#           version: '8.0.x'
      
#       # Step 3: Restore dependencies
#       - task: DotNetCoreCLI@2
#         displayName: 'Restore dependencies'
#         inputs:
#           command: 'restore'
#           projects: '**/*.csproj'
      
#       # Step 4: Build application
#       - task: DotNetCoreCLI@2
#         displayName: 'Build application'
#         inputs:
#           command: 'build'
#           projects: '**/*.csproj'
#           arguments: '--configuration Release --no-restore'
      
#       # Step 5: Run tests
#       - task: DotNetCoreCLI@2
#         displayName: 'Run tests'
#         inputs:
#           command: 'test'
#           projects: '**/*Tests/*.csproj'
#           arguments: '--configuration Release --no-build --verbosity normal'
      
#       # Step 6: Docker login
#       - task: Docker@2
#         displayName: 'Login to Azure Container Registry'
#         inputs:
#           command: 'login'
#           containerRegistry: 'acr-connection'
      
#       # Step 7: Build and push Docker image
#       - task: Docker@2
#         displayName: 'Build and Push Docker Image'
#         inputs:
#           command: 'buildAndPush'
#           repository: '$(imageName)'
#           dockerfile: 'Dockerfile'
#           buildContext: '$(System.DefaultWorkingDirectory)'
#           containerRegistry: 'acr-connection'
#           tags: |
#             $(tag)
#             latest
      
#       # Step 8: Publish Kubernetes manifests
#       - task: PublishBuildArtifacts@1
#         displayName: 'Publish Kubernetes Manifests'
#         inputs:
#           PathtoPublish: '$(System.DefaultWorkingDirectory)/kubernetes'
#           ArtifactName: 'manifests'

#   # STAGE 2: DEV DEPLOYMENT (Automatic)
#   - stage: Dev
#     displayName: 'Deploy to Dev'
#     dependsOn: Build
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToDev
#       displayName: 'Deploy to Dev AKS'
#       environment: 'dev'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             # Step 1: Download manifests
#             - download: current
#               artifact: manifests
            
#             # Step 2: Create namespace if not exists
#             - task: Bash@3
#               displayName: 'Create dev namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(devNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             # Step 3: Replace image placeholder in deployment
#             - task: Bash@3
#               displayName: 'Update deployment with image tag'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
            
#             # Step 4: Deploy to dev namespace
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Dev'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(devNamespace)

#   # STAGE 3: TEST DEPLOYMENT (Requires approval)
#   - stage: Test
#     displayName: 'Deploy to Test'
#     dependsOn: Dev
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToTest
#       displayName: 'Deploy to Test AKS'
#       environment: 'test'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             - download: current
#               artifact: manifests
            
#             - task: Bash@3
#               displayName: 'Create test namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(testNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Test'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(testNamespace)

#   # STAGE 4: PRODUCTION DEPLOYMENT (Requires approval)
#   - stage: Prod
#     displayName: 'Deploy to Production'
#     dependsOn: Test
#     condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
#     jobs:
#     - deployment: DeployToProd
#       displayName: 'Deploy to Production AKS'
#       environment: 'prod'
#       pool: 'my-linux-agent'   # ✅ FIXED: Added pool for deployment job
#       strategy:
#         runOnce:
#           deploy:
#             steps:
#             - download: current
#               artifact: manifests
            
#             - task: Bash@3
#               displayName: 'Create prod namespace'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Ensure kubectl uses minikube context
#                   kubectl config use-context minikube
#                   kubectl create namespace $(prodNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
#             - task: Bash@3   # ✅ CHANGED: Replaced Kubernetes@1 with Bash task
#               displayName: 'Deploy to Production'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   # Use minikube context and deploy manifests
#                   kubectl config use-context minikube
#                   kubectl apply -f $(Pipeline.Workspace)/manifests -n $(prodNamespace)
















































# .azuredevops/pipelines/multi-stage-pipeline.yml
name: $(Build.SourceBranchName)-$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - master
      - release/*
  paths:
    exclude:
      - README.md
      - '*.md'

pr:
  branches:
    include:
      - master
      - release/*
      - develop
  paths:
    exclude:
      - README.md
      - '*.md'

variables:
  # ACR Details
  - name: acrName
    value: 'myacrdemo2025'
  - name: acrLoginServer
    value: '$(acrName).azurecr.io'
  - name: imageName
    value: 'myapp'
  - name: tag
    value: '$(Build.SourceBranchName)-$(Build.BuildId)'
  
  # AKS Namespaces
  - name: devNamespace
    value: 'dev-namespace'
  - name: testNamespace
    value: 'test-namespace'
  - name: prodNamespace
    value: 'prod-namespace'

stages:
  # STAGE 1: BUILD
  - stage: Build
    displayName: 'Build Docker Image'
    jobs:
    - job: BuildJob
      displayName: 'Build and Push to ACR'
      pool: 'my-linux-agent'
      
      steps:
      # Step 1: Checkout code
      - checkout: self
        fetchDepth: 1
      
      # Step 2: Setup .NET
      - task: UseDotNet@2
        displayName: 'Use .NET 8.0'
        inputs:
          version: '8.0.x'
      
      # Step 3: Restore dependencies
      - task: DotNetCoreCLI@2
        displayName: 'Restore dependencies'
        inputs:
          command: 'restore'
          projects: '**/*.csproj'
      
      # Step 4: Build application
      - task: DotNetCoreCLI@2
        displayName: 'Build application'
        inputs:
          command: 'build'
          projects: '**/*.csproj'
          arguments: '--configuration Release --no-restore'
      
      # Step 5: Run tests
      - task: DotNetCoreCLI@2
        displayName: 'Run tests'
        inputs:
          command: 'test'
          projects: '**/*Tests/*.csproj'
          arguments: '--configuration Release --no-build --verbosity normal'
      
      # Step 6: Docker login
      - task: Docker@2
        displayName: 'Login to Azure Container Registry'
        inputs:
          command: 'login'
          containerRegistry: 'acr-connection'
      
      # Step 7: Build and push Docker image
      - task: Docker@2
        displayName: 'Build and Push Docker Image'
        inputs:
          command: 'buildAndPush'
          repository: '$(imageName)'
          dockerfile: 'Dockerfile'
          buildContext: '$(System.DefaultWorkingDirectory)'
          containerRegistry: 'acr-connection'
          tags: |
            $(tag)
            latest
          # ADDED: Ensure proper build configuration
          arguments: '--build-arg BUILD_CONFIGURATION=Release'
      
      # Step 8: Publish Kubernetes manifests
      - task: PublishBuildArtifacts@1
        displayName: 'Publish Kubernetes Manifests'
        inputs:
          PathtoPublish: '$(System.DefaultWorkingDirectory)/kubernetes'
          ArtifactName: 'manifests'
      
      # Step 9: Log build info
      - task: Bash@3
        displayName: 'Log Build Information'
        inputs:
          targetType: 'inline'
          script: |
            echo "##vso[task.setvariable variable=BUILD_INFO]Build $(Build.BuildId) completed"
            echo "Image Tag: $(tag)"
            echo "Full Image: $(acrLoginServer)/$(imageName):$(tag)"

  # STAGE 2: DEV DEPLOYMENT (Automatic)
  - stage: Dev
    displayName: 'Deploy to Dev'
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToDev
      displayName: 'Deploy to Dev AKS'
      environment: 'dev'
      pool: 'my-linux-agent'
      strategy:
        runOnce:
          deploy:
            steps:
            # Step 1: Download manifests
            - download: current
              artifact: manifests
            
            # Step 2: DEBUG - Show variables
            - task: Bash@3
              displayName: 'DEBUG: Show Build Information'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Build ID: $(Build.BuildId)"
                  echo "Tag: $(tag)"
                  echo "Image: $(acrLoginServer)/$(imageName):$(tag)"
                  echo "--- Checking manifests ---"
                  ls -la $(Pipeline.Workspace)/manifests/
                  echo "--- Deployment YAML before update ---"
                  grep -n "image:" $(Pipeline.Workspace)/manifests/deployment.yaml || echo "No image found in deployment.yaml"
            
            # Step 3: Create namespace if not exists
            - task: Bash@3
              displayName: 'Create dev namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl create namespace $(devNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
            # Step 4: Replace image placeholder in deployment
            - task: Bash@3
              displayName: 'Update deployment with image tag'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Updating deployment.yaml..."
                  echo "Replacing placeholder with: $(acrLoginServer)/$(imageName):$(tag)"
                  
                  # Backup original
                  cp $(Pipeline.Workspace)/manifests/deployment.yaml $(Pipeline.Workspace)/manifests/deployment.yaml.backup
                  
                  # Replace placeholder
                  sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
                  
                  # Verify replacement
                  echo "--- Deployment YAML after update ---"
                  grep -n "image:" $(Pipeline.Workspace)/manifests/deployment.yaml
                  
                  # Also update if there's a hardcoded image (backup fix)
                  sed -i "s|myacrdemo2025\.azurecr\.io/myapp:latest|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
                  echo "--- Final check ---"
                  grep "image:" $(Pipeline.Workspace)/manifests/deployment.yaml
            
            # Step 5: Deploy to dev namespace
            - task: Bash@3
              displayName: 'Deploy to Dev'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  echo "Applying manifests to $(devNamespace)..."
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(devNamespace)
            
            # Step 6: Wait for rollout
            - task: Bash@3
              displayName: 'Wait for rollout completion'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Waiting for deployment rollout..."
                  timeout 300 kubectl rollout status deployment/myapp-deployment -n $(devNamespace) --watch
                  
                  if [ $? -eq 0 ]; then
                    echo "✅ Rollout completed successfully"
                  else
                    echo "❌ Rollout failed or timed out"
                    kubectl describe deployment myapp-deployment -n $(devNamespace)
                    exit 1
                  fi
            
            # Step 7: Verify deployment
            - task: Bash@3
              displayName: 'Verify Deployment'
              inputs:
                targetType: 'inline'
                script: |
                  echo "=== Verification Steps ==="
                  
                  # Check deployed image
                  echo "1. Checking deployed image..."
                  DEPLOYED_IMAGE=$(kubectl get deployment myapp-deployment -n $(devNamespace) \
                    -o jsonpath='{.spec.template.spec.containers[0].image}')
                  echo "   Deployed: $DEPLOYED_IMAGE"
                  echo "   Expected: $(acrLoginServer)/$(imageName):$(tag)"
                  
                  if [ "$DEPLOYED_IMAGE" = "$(acrLoginServer)/$(imageName):$(tag)" ]; then
                    echo "   ✅ Image matches expected tag"
                  else
                    echo "   ⚠️  Image doesn't match expected tag"
                  fi
                  
                  # Check pod status
                  echo -e "\n2. Checking pod status..."
                  kubectl get pods -n $(devNamespace) -l app=myapp -o wide
                  
                  # Test application
                  echo -e "\n3. Testing application..."
                  kubectl port-forward deployment/myapp-deployment 8080:8080 -n $(devNamespace) &
                  PID=$!
                  sleep 15  # Give more time for app to start
                  
                  if curl -s --retry 3 --retry-delay 5 http://localhost:8080 | grep -q "CI/CD Dashboard"; then
                    echo "   ✅ Dashboard detected!"
                    echo "   Build $(tag) is running successfully"
                  else
                    echo "   ⚠️  Dashboard not found. Response preview:"
                    curl -s http://localhost:8080 | head -2
                  fi
                  
                  kill $PID 2>/dev/null
                  
                  echo -e "\n✅ Dev deployment verification complete!"

  # STAGE 3: TEST DEPLOYMENT (Requires approval)
  - stage: Test
    displayName: 'Deploy to Test'
    dependsOn: Dev
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToTest
      displayName: 'Deploy to Test AKS'
      environment: 'test'
      pool: 'my-linux-agent'
      strategy:
        runOnce:
          deploy:
            steps:
            # Step 1: Download manifests
            - download: current
              artifact: manifests
            
            # Step 2: Create test namespace
            - task: Bash@3
              displayName: 'Create test namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl create namespace $(testNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
            # Step 3: Update image in manifests for test
            - task: Bash@3
              displayName: 'Update image for test deployment'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Updating deployment for test environment..."
                  sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
                  sed -i "s|myacrdemo2025\.azurecr\.io/myapp:latest|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
            
            # Step 4: Deploy to test
            - task: Bash@3
              displayName: 'Deploy to Test'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(testNamespace)
            
            # Step 5: Verify test deployment
            - task: Bash@3
              displayName: 'Verify Test Deployment'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Waiting for test deployment..."
                  kubectl rollout status deployment/myapp-deployment -n $(testNamespace) --timeout=180s
                  echo "✅ Test deployment successful"

  # STAGE 4: PRODUCTION DEPLOYMENT (Requires approval)
  - stage: Prod
    displayName: 'Deploy to Production'
    dependsOn: Test
    condition: and(succeeded(), or(eq(variables['Build.SourceBranchName'], 'master'), eq(variables['Build.SourceBranchName'], 'main')))
    
    jobs:
    - deployment: DeployToProd
      displayName: 'Deploy to Production AKS'
      environment: 'prod'
      pool: 'my-linux-agent'
      strategy:
        runOnce:
          deploy:
            steps:
            # Step 1: Download manifests
            - download: current
              artifact: manifests
            
            # Step 2: Create prod namespace
            - task: Bash@3
              displayName: 'Create prod namespace'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl create namespace $(prodNamespace) --dry-run=client -o yaml | kubectl apply -f -
            
            # Step 3: Update image for production
            - task: Bash@3
              displayName: 'Update image for production'
              inputs:
                targetType: 'inline'
                script: |
                  echo "Updating deployment for production..."
                  sed -i "s|CONTAINER_IMAGE_PLACEHOLDER|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
                  sed -i "s|myacrdemo2025\.azurecr\.io/myapp:latest|$(acrLoginServer)/$(imageName):$(tag)|g" $(Pipeline.Workspace)/manifests/deployment.yaml
            
            # Step 4: Deploy to production
            - task: Bash@3
              displayName: 'Deploy to Production'
              inputs:
                targetType: 'inline'
                script: |
                  kubectl config use-context minikube
                  kubectl apply -f $(Pipeline.Workspace)/manifests -n $(prodNamespace)
            
            # Step 5: Final verification
            - task: Bash@3
              displayName: 'Production Verification'
              inputs:
                targetType: 'inline'
                script: |
                  echo "=== Production Deployment Complete ==="
                  echo "Image: $(acrLoginServer)/$(imageName):$(tag)"
                  echo "Namespace: $(prodNamespace)"
                  echo "Timestamp: $(date)"
                  echo ""
                  echo "To access the application:"
                  echo "1. kubectl port-forward deployment/myapp-deployment 8080:8080 -n $(prodNamespace)"
                  echo "2. Open http://localhost:8080 in your browser"
                  echo ""
                  echo "✅ Production deployment pipeline completed!"